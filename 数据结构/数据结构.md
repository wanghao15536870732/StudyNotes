
# 顺序表的两道课后题

## 将顺序表(a1,a2,…,an)重新排列以a1为界的两部分：a1前面的值均比a1小，a1后面的值均比a1大（这里假设数据元素的类型具有可比性，不妨设为整型）。

+ ### 主要的函数

```c
/***********************************************/
/* 函数功能：将顺序表重新排列,a1位置为界
分为两部分，position前面的值均比a1的数值小
position后面的值均比a1的数值大  */
/***********************************************/
void compare(sequence_list *slt)
{
    if(!slt->size)
        printf("\n顺序表是空的！\n");
    else
    {
        //首先保存第一个学生的成绩
        int score = slt->score[0];
        for(int i = 1;i < slt->size;i ++)
        {
            if(slt->score[i] < score)
            {
                //如果遍历学生的成绩大于排头，将该数据插入到第一位
                insert(slt,slt->a[i],0,slt->name[i],slt->score[i]);
                //删除刚刚移动的那个原数据
                dele(slt,i + 1);
            }
        }
    }
}
```

+ ### [整体的代码](https://github.com/wanghao15536870732/StudyNotes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8%20--%20%E4%BB%A5a1%E4%B8%BA%E7%95%8C%E9%99%90%E5%88%92%E5%88%86.cpp)

### 演示：

![K](https://upload-images.jianshu.io/upload_images/9140378-92e420bc219a8918.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540)

## 有顺序表A和B，其元素均按从小到大的升序排列，编写一个算法，将它们合并成一个顺序表C，要求C的元素也按从小到大的升序排列。

### 第一种方法，新开辟一个顺序表，将两个顺序表依次加入新的顺序表

```c
/********************************************************/
/* 函数功能：将顺序表slt1跟顺序表slt2顺序连接到stl3当中*/        
/******************************************************/
void sort_insert(sequence_list *slt1,sequence_list *slt2,sequence_list *slt3)
{
    int i = 0,j = 0; //i用于扫描顺序表slt1,j用于扫描顺序表slt2
    if(slt1->size == 0 || slt2->size == 0)
        printf("有空的顺序表!\n");
    while(i < slt1->size && j < slt2->size)
    {
        if(slt1->score[i] < slt2->score[j])
        {
            //在slt3的后面添加slt1的数据
            append(slt3,slt1->a[i],slt1->name[i],slt1->score[i]);
            //
            i ++;
        }
        else
        {
            //在slt3的后面添加slt2的数据
            append(slt3,slt2->a[j],slt2->name[j],slt2->score[j]);
            j ++;
        }
    }

    while(i < slt1->size)//若slt1未扫描完，则将slt1剩余的元素加到slt3中
    {
        append(slt3,slt1->a[i],slt1->name[i],slt1->score[i]);
        i ++;
    }

    while(j < slt2->size)//若slt2未扫描完，则将slt2剩余的元素加到slt3中
    {
        append(slt3,slt2->a[j],slt2->name[j],slt2->score[j]);
        j ++;
    }
}
```

### 第二种方法，直接将顺序表A顺序的插到顺序表B当中

```c
/********************************************************/
/* 函数功能：将顺序表slt1跟顺序表顺序的插到slt2当中*****/        
/******************************************************/
void sort_insert2(sequence_list *slt1,sequence_list *slt2)
{
    int i = 0,j = 0;
    while(i < slt1->size)
    {
        //如果顺序表slt1的数据比slt2最大的都大，直接将slt1的数据加到slt2后面 
        if(slt1->score[i] > slt2->score[slt2->size - 1])
        {
            append(slt2,slt1->a[i],slt1->name[i],slt1->score[i]);
            i ++;
        }else if(slt1->score[i] < slt2->score[j])  //如果序表slt1的数据比slt2位置j上的的要小 
        {
            // 将slt1的数据插入到slt2的 j 的位置 
            insert(slt2,slt1->a[i],j,slt1->name[i],slt1->score[i]); 
            //两个顺序表都向后扫描 
            i ++;
            j ++;
        }else
            //向后扫描slt2 
            j ++;
    }
}
```

+ ### [整体代码](https://github.com/wanghao15536870732/StudyNotes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%A1%BA%E5%BA%8F%E8%A1%A8%20--%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%90%88%E6%88%90.cpp)

### 演示

![W{7Z7L)E`)5(UEKPVXY)N6C.png](https://upload-images.jianshu.io/upload_images/9140378-c380725578215b0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540)

# 栈的应用 -- 括号匹配

## 主要的代码

```c
int match_kouhao(char c[])
{
    int i = 0;
    sequence_stack s;
    init(&s);
    while(c[i] != '#')
    {
        switch(c[i])
        {
            case '{':
            case '[':
            case '(': 
                push(&s,c[i]); 
                break;
            case '}': 
                if(!empty(s) && read(s) == '{')
                {
                    pop(&s);
                    break;
                }
                else
                    return 0;
            case ']':
                if(!empty(s) && read(s) == '[')
                {
                    pop(&s);
                    break;
                }
                else
                    return 0;
            case ')':
                if(!empty(s) && read(s) == '(')
                {
                    pop(&s);
                    break;
                }
                else
                    return 0;
        }
        i ++;
    }
    return (empty(s));
}
```

+ ## [整体代码](https://github.com/wanghao15536870732/StudyNotes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%20--%20%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D.cpp)

## 结果演示：

![091$D4N)EK7`YBQ~8GBJKJD.png](https://upload-images.jianshu.io/upload_images/9140378-9417e716f0973f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)

# 中缀、后缀表达式

+ 3 + 4) × 5 / 6 中缀表达式
+ 3 4 + 5 × 6 / 后缀表达式

## 后缀表达式（后缀记法、逆波兰式）

+ 后缀表达式与前缀表达式类似，只是运算符位于操作数之后。

## 后缀表达式的计算机求值：

### 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果。例如后缀表达式“3 4 + 5 × 6 -”：

+ (1) 从左至右扫描，将3和4压入堆栈；
+ (2) 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈；
+ (3) 将5入栈；
+ (4) 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
+ (5) 将6入栈；
+ (6) 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。

## 将中缀表达式转换为后缀表达式：

+ (1) 初始化两个栈：运算符栈S1和储存中间结果的栈S2；
+ (2) 从左至右扫描中缀表达式；
+ (3) 遇到操作数时，将其压入S2；
+ (4) 遇到运算符时，比较其与S1栈顶运算符的优先级：
+ (4-1) 如果S1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
+ (4-2) 否则，若优先级比栈顶运算符的高，也将运算符压入S1（注意转换为前缀表达式时是优先级较高或相同，而这里则不包括相同的情况）
+ (4-3) 否则，将S1栈顶的运算符弹出并压入到S2中，再次转到(4-1)与S1中新的栈顶运算符相比较；
+ (5) 遇到括号时：
+ (5-1) 如果是左括号“(”，则直接压入S1；
+ (5-2) 如果是右括号“)”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到左括号为止，此时将这一对括号丢弃；
+ (6) 重复步骤(2)至(5)，直到表达式的最右边；
+ (7) 将S1中剩余的运算符依次弹出并压入S2；
+ (8) 依次弹出S2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（转换为前缀表达式时不用逆序）

## 例如，将中缀表达式 a * (b + c) - d 转换为后缀表达式的过程如下：

|||||
|:--|:--|:--|:--|
|扫描到的元素|S2(栈底->栈顶)|S1 (栈底->栈顶)|说明|
|a|a||操作符压入s2|
|*|a|*|运算符压入s1|
|(|a|* (| ' ( ' 优先级比 ' * ' 高,直接将该运算符压入s1|
|b|a b|* (| 操作符压入s2|
|+|a b | * ( + |s2 栈顶元素为 ' ( ' 直接入栈|
|c|a b c | * ( +| 操作符压入 s1 栈|
|)|a b c + | * | 与 s2 栈中元素 ' ( ' 匹配，将 ' + ' 弹出压入s1,匹配好的括号直接出栈 |
|-| a b c + * | - | ' - ' 运算符优先级低于 ' * '，将 ' * ' 弹出 s1 ,压入 s2  ，' - ' 压入 s1|
|d|a b c + * d | -| 操作符压入 栈 s1 |
||a b c + * d -||最后将 s2 所有元素弹出压入 s1|

+ ## 结果为 a b c + * d -

## 具体代码实现

```c
/****************************************/
/****** 判断一个字符串是否为运算符 ******/
/****************************************/
int is_operation(char op)
{
    switch(op)
    {
        case '+':
        case '-':
        case '*':
        case '-/': return 1;
        default:return 0;
    }
}
```

```c

/****************************************/
/*********** 求运算符的优先级 ***********/
/****************************************/
int priority(char op)
{
    switch(op)
    {
        case '#': return -1;
      case '(': return 0;
      case '+': 
        case '-': return 1;
        case '*':
        case '/': return 2;
        default: return -1;
    }
}
```

```c

/***************************************************/
/* 将一个中缀表达式 e 转换成与它等价的后缀表达式 f */
/***************************************************/

void postfix(char e[],char f[])
{
    int i = 0,j = 0;
    char opst[100];
    int top,t;
    top = 0;
    opst[top] = '#'; 
    top ++;
    while(e[i])
    {
        if((e[i] >= '0' && e[i] <= '9') || e[i] == '.')
            f[j ++] = e[i];  // 遇到数字或者小鼠点直接写入后缀表达式
        else if( e[i] == '(')  // 遇到左括号进入操作符栈
        {
            opst[top] == e[i]; 
            top ++;
        }
        else if(e[i] == ')')
            //遇到右括号将其对应的左括号后的操作符全部写入后缀表达式 
        {
            t = top - 1;
            while(opst[t] != '(')
            {
                f[j ++] = opst[-- top];
                t = top - 1;
            }
            top --; // '( ' 出栈
        }
        else if(is_operation(e[i])) // '+ 、-、*、/ '
        {
            f[j ++] = ' '; // 用空格分开两个操作符
            while(priority(opst[top - 1]) >= priority(e[i]))
                f[j ++] = opst[-- top];
            opst[top] = e[i];
            top ++;// 当前元素入栈
        }
        i ++;// 处理下一个元素
    }
    while(top)
        f[j ++] = opst[-- top];
}
```

+ ## [具体代码](https://github.com/wanghao15536870732/StudyNotes/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F.cpp)

### 写的有点仓促，难免会有一些小差错，如有任何错误，欢迎指正，谢谢！
